<?php
// @codingStandardsIgnoreFile
declare(strict_types=1);

namespace Ls\Core\Code;

use CaseHelper\CaseHelperFactory;
use CaseHelper\CaseHelperInterface;
use Exception;
use Laminas\Code\Generator\DocBlock\Tag;
use Laminas\Code\Generator\ClassGenerator;
use Laminas\Code\Generator\DocBlockGenerator;
use Laminas\Code\Generator\FileGenerator;
use Laminas\Code\Generator\GeneratorInterface;
use Laminas\Code\Generator\MethodGenerator;
use Laminas\Code\Generator\ParameterGenerator;
use Laminas\Code\Generator\PropertyGenerator;
use ReflectionNamedType;

abstract class AbstractGenerator implements GeneratorInterface
{
    /** @var FileGenerator */
    public $file;

    /** @var ClassGenerator */
    public $class;

    /** @var CaseHelperInterface */
    public $caseHelper;

    /** @var string */
    public $disclaimer = <<<DISCLAIMER
THIS IS AN AUTOGENERATED FILE
DO NOT MODIFY
@codingStandardsIgnoreFile
DISCLAIMER;

    /**
     * @throws Exception
     */
    public function __construct()
    {
        $this->file = new FileGenerator();
        $this->file->setDocBlock(DocBlockGenerator::fromArray(['shortdescription' => $this->disclaimer]));
        $this->class = new ClassGenerator();
        $this->caseHelper = CaseHelperFactory::make(CaseHelperFactory::INPUT_TYPE_PASCAL_CASE);
        $this->file->setClass($this->class);
    }

    /**
     * Joins given arguments into a fully-qualified class name.
     *
     * @param string ...$parts
     * @return string
     */
    public static function fqn(...$parts): string
    {
        return join('\\', $parts);
    }

    /**
     * Joins given arguments into a file system path.
     *
     * @param string ...$parts
     * @return string
     */
    public static function path(...$parts): string
    {
        return join(DIRECTORY_SEPARATOR, $parts);
    }

    /**
     * Returns the file generator instance.
     *
     * @return FileGenerator
     */
    protected function getFile(): FileGenerator
    {
        return $this->file;
    }

    /**
     * Returns the class generator instance.
     *
     * @return ClassGenerator
     */
    protected function getClass(): ClassGenerator
    {
        return $this->class;
    }

    /**
     * Creates a property with optional getter and setter methods.
     *
     * @param string|null $name
     * @param string $type
     * @param array $flags
     * @param array $options
     * @param bool $defineProperty
     * @return void
     */
    protected function createProperty(
        ?string $name,
        string $type = 'mixed',
        array $flags = [PropertyGenerator::FLAG_PROTECTED],
        array $options = [],
        bool $defineProperty = false
    ): void {
        $pascalName = $options['pascal_name'] ?? ucfirst($this->caseHelper->toCamelCase($name));
        $variableName = $options['variable_name'] ?? lcfirst($this->caseHelper->toCamelCase($name));
        $variableField = $options['variable_field'] ?? $variableName;

        $setMethod = new MethodGenerator();
        $getMethod = new MethodGenerator();

        $setMethod->setName("set$pascalName");
        $getMethod->setName("get$pascalName");
        $getMethod->setVisibility(MethodGenerator::VISIBILITY_PUBLIC);
        $setMethod->setVisibility(MethodGenerator::VISIBILITY_PUBLIC);
        $getMethod->setReturnType($type);
        $setMethod->setParameter(new ParameterGenerator($variableName, $type));

        if (key_exists('abstract', $options)) {
            $getMethod->setAbstract(true);
            $setMethod->setAbstract(true);
        }

        if (!array_key_exists('abstract', $options) && !array_key_exists('interface', $options)) {
            if (array_key_exists('model', $options)) {
                if ($variableField === 'Dimensions') {
                    $setMethod->setBody(<<<CODE
if (trim(\$$variableName) != "" && \$$variableName != null) {
    \$this->setData('$variableField', \$$variableName);
    \$this->setDataChanges(true);
}
return \$this;
CODE);
                } else {
                    $setMethod->setBody(<<<CODE
\$this->setData('$variableField', \$$variableName);
\$this->setDataChanges(true);
return \$this;
CODE);
                }

                $getMethod->setBody(<<<CODE
return \$this->getData('$variableField');
CODE);
            } else {
                if ($defineProperty) {
                    $setMethod->setBody(<<<CODE
\$this->{$variableField} = \$$variableName;
return \$this;
CODE);
                    $getMethod->setBody(<<<CODE
return \$this->{$variableField};
CODE);
                } else {
                    $setMethod->setBody(<<<CODE
\$this->setData('$variableField', \$$variableName);
return \$this;
CODE);
                    $getMethod->setBody(<<<CODE
return \$this->$variableField;
CODE);
                }
            }
        }
        if ($defineProperty) {
            $property_comment = DocBlockGenerator::fromArray([
                'tags' => [
                    new Tag\PropertyTag(
                        $variableName,
                        [$type]
                    )
                ]
            ]);
            $property         = PropertyGenerator::fromArray([
                'name'     => $variableName,
                'flags'    => $flags,
                'docblock' => $property_comment
            ]);

            $this->class->addPropertyFromGenerator($property);
        }


        $this->class->addMethodFromGenerator($setMethod);
        $this->class->addMethodFromGenerator($getMethod);
    }

    /**
     * Copies a given method definition into the generated class.
     *
     * @param string $methodName
     * @param string $visibility
     * @param bool $isAbstract
     * @param array $flags
     * @param array $parameters
     * @param ReflectionNamedType|null $returnType
     * @param string $body
     * @return void
     */
    public function copyGivenMethod(
        string $methodName,
        string $visibility,
        bool $isAbstract = false,
        array $flags = [],
        array $parameters = [],
        ?ReflectionNamedType $returnType = null,
        string $body = ''
    ): void {
        $methodGen = new MethodGenerator();
        $methodGen->setName($methodName);
        $methodGen->setVisibility($visibility);
        $methodGen->setAbstract($isAbstract);
        $methodGen->setFlags($flags);

        $builtinTypes = [
            'int', 'float', 'string', 'bool', 'array', 'object', 'mixed', 'void',
            'callable', 'iterable', 'null', 'false', 'true', 'never'
        ];
        $specialTypes = ['self', 'static', 'parent'];

        foreach ($parameters as $param) {
            $paramGen = new ParameterGenerator($param->getName());

            if ($param->hasType()) {
                $type = $param->getType();
                if ($type instanceof ReflectionNamedType) {
                    $typeName = $type->getName();
                    $nullablePrefix = $type->allowsNull() ? '?' : '';

                    if (!in_array($typeName, $builtinTypes, true) && !in_array($typeName, $specialTypes, true)) {
                        $typeName = '\\' . ltrim($typeName, '\\');
                    }

                    $paramGen->setType($nullablePrefix . $typeName);
                }
            }

            if ($param->isDefaultValueAvailable()) {
                $paramGen->setDefaultValue($param->getDefaultValue());
            }

            $methodGen->setParameter($paramGen);
        }

        if ($returnType instanceof ReflectionNamedType) {
            $typeName = $returnType->getName();
            $nullablePrefix = $returnType->allowsNull() ? '?' : '';
            $lowerTypeName = strtolower($typeName);

            $resolvedType = in_array($lowerTypeName, $builtinTypes, true) || in_array($lowerTypeName, $specialTypes, true)
                ? $nullablePrefix . $typeName
                : $nullablePrefix . '\\' . ltrim($typeName, '\\');

            $methodGen->setReturnType($resolvedType);
        }

        if (!empty($body)) {
            $methodGen->setBody($body);
        }

        $this->class->addMethodFromGenerator($methodGen);
    }

    /**
     * Fix invalid leading backslashes on special PHP types
     *
     * @param string $content
     * @return string
     */
    public function removeBackSlashFromBuiltinReturnTypes(string $content): string
    {
        return preg_replace(
            '/(?<!\w)\\\(self|static|parent|bool|int|string|float|array|object)\b/',
            '$1',
            $content
        );
    }
}
